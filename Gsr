
-- ============================================
-- MISSWARE P100 V5 - COMPLETE EDITION
-- Resolver + Killsay + Clantag
-- Optimized & Enhanced
-- ============================================

local script = {
    name = "MISSWARE P100",
    version = "5.0",
    author = "Enhanced"
}

-- ============================================
-- PERFORMANCE OPTIMIZATIONS - CACHED FUNCTIONS
-- ============================================
local ui_get, ui_set = ui.get, ui.set
local ui_set_visible = ui.set_visible
local ui_new_checkbox = ui.new_checkbox
local ui_new_combobox = ui.new_combobox
local ui_new_slider = ui.new_slider
local ui_new_textbox = ui.new_textbox
local ui_set_callback = ui.set_callback
local ui_reference = ui.reference
local entity_get_local_player = entity.get_local_player
local entity_get_players = entity.get_players
local entity_is_alive = entity.is_alive
local entity_get_prop = entity.get_prop
local entity_get_player_name = entity.get_player_name
local globals_tickcount = globals.tickcount
local globals_curtime = globals.curtime
local globals_realtime = globals.realtime
local client_set_event_callback = client.set_event_callback
local client_exec = client.exec
local client_delay_call = client.delay_call
local client_userid_to_entindex = client.userid_to_entindex
local client_set_clan_tag = client.set_clan_tag
local client_color_log = client.color_log
local renderer_text = renderer.text
local plist_set = plist.set
local plist_get = plist.get
local math_random = math.random
local math_floor = math.floor
local math_min = math.min
local math_max = math.max
local math_sin = math.sin
local math_sqrt = math.sqrt
local math_deg = math.deg
local math_atan2 = math.atan2
local table_insert = table.insert
local table_concat = table.concat
local table_remove = table.remove
local string_format = string.format
local string_rep = string.rep

-- ============================================
-- UTILITY FUNCTIONS
-- ============================================
local function safe_get_combobox(value)
    if type(value) == "table" then return value[1] or 0 end
    return value or 0
end

-- ============================================
-- UI ELEMENTS
-- ============================================
local menu = {}

-- RESOLVER SECTION
menu.resolver_enable = ui_new_checkbox("LUA", "B", "═══ RESOLVER ═══")
menu.resolver_mode = ui_new_combobox("LUA", "B", "Resolver Mode", {
    "Adaptive",      -- Smart learning
    "Bruteforce",    -- Cycle angles
    "Prediction",    -- Velocity-based
    "Smart Hybrid"   -- Best of all
})
menu.anti_freestand = ui_new_checkbox("LUA", "B", "Anti-Freestand Override")
menu.shot_correction = ui_new_checkbox("LUA", "B", "Miss-Based Correction")
menu.aggression = ui_new_slider("LUA", "B", "Resolver Aggression", 1, 100, 50, true, "%")
menu.resolver_debug = ui_new_checkbox("LUA", "B", "Resolver Debug Info")

-- KILLSAY SECTION
menu.killsay_enable = ui_new_checkbox("LUA", "B", "\n═══ KILLSAY ═══")
menu.killsay_mode = ui_new_combobox("LUA", "B", "Chat Mode", {"Team", "All"})
menu.killsay_style = ui_new_combobox("LUA", "B", "Style", {
    "Toxic", "Troll", "Meme", "Professional", "Custom Mix"
})
menu.killsay_delay = ui_new_slider("LUA", "B", "Delay (ms)", 0, 2000, 300, true, "ms")
menu.on_kill = ui_new_checkbox("LUA", "B", "On Kill")
menu.on_headshot = ui_new_checkbox("LUA", "B", "On Headshot")
menu.on_knife = ui_new_checkbox("LUA", "B", "On Knife")
menu.on_multi = ui_new_checkbox("LUA", "B", "Multi-kill Messages")
menu.multi_threshold = ui_new_slider("LUA", "B", "Multi-kill Count", 2, 5, 2, true, " kills")
menu.death_responses = ui_new_checkbox("LUA", "B", "Death Responses")
menu.death_style = ui_new_combobox("LUA", "B", "Death Style", {
    "Excuses", "Salty", "Funny", "Blame", "Toxic"
})
menu.domination = ui_new_checkbox("LUA", "B", "Domination Messages")
menu.domination_count = ui_new_slider("LUA", "B", "Domination Threshold", 2, 10, 3, true, " kills")

-- CLANTAG SECTION
menu.clantag_enable = ui_new_checkbox("LUA", "B", "\n═══ CLANTAG ═══")
menu.clantag_preset = ui_new_combobox("LUA", "B", "Preset", {
    "Custom", "MISSWARE", "P100", "GODLIKE", "EZ", "1TAP", "RESOLVER", "GAMING", "PRO", "HVHGOD"
})
menu.clantag_custom_text = ui_new_textbox("LUA", "B", "Custom Text")
menu.clantag_animation = ui_new_combobox("LUA", "B", "Animation", {
    "Scroll", "Fade", "Blink", "Wave", "Typewriter", "Reverse", "Ping-Pong", "Rainbow", "Glitch", "Bounce"
})
menu.clantag_speed = ui_new_slider("LUA", "B", "Animation Speed", 1, 50, 10, true, "x")
menu.clantag_separator = ui_new_combobox("LUA", "B", "Separator", {
    "None", "[ ]", "{ }", "( )", "| |", "< >", "» «", "★ ★", "• •", "~ ~"
})
menu.clantag_prefix = ui_new_textbox("LUA", "B", "Prefix")
menu.clantag_suffix = ui_new_textbox("LUA", "B", "Suffix")
menu.clantag_max_length = ui_new_slider("LUA", "B", "Max Length", 5, 20, 15, true, " chars")

-- DIAGNOSTICS
menu.show_diagnostics = ui_new_checkbox("LUA", "B", "\n═══ DIAGNOSTICS ═══")

-- Set default values
ui_set(menu.resolver_enable, true)
ui_set(menu.resolver_mode, 3) -- Smart Hybrid
ui_set(menu.anti_freestand, true)
ui_set(menu.shot_correction, true)
ui_set(menu.on_kill, true)
ui_set(menu.on_headshot, true)
ui_set(menu.killsay_delay, 300)

-- ============================================
-- CHEAT REFERENCES
-- ============================================
local ref = {
    pitch = ui_reference("AA", "Anti-aimbot angles", "Pitch"),
    yaw_base = ui_reference("AA", "Anti-aimbot angles", "Yaw base"),
    yaw = ui_reference("AA", "Anti-aimbot angles", "Yaw"),
    jitter = ui_reference("AA", "Anti-aimbot angles", "Yaw jitter"),
    body_yaw = ui_reference("AA", "Anti-aimbot angles", "Body yaw"),
    freestand = {ui_reference("AA", "Anti-aimbot angles", "Freestanding")},
    edge_yaw = ui_reference("AA", "Anti-aimbot angles", "Edge yaw"),
}

-- ============================================
-- RESOLVER DATA STORAGE
-- ============================================
local resolver_data = {}

local function init_player_data(player)
    if not resolver_data[player] then
        resolver_data[player] = {
            misses = 0,
            last_miss_tick = 0,
            brute_phase = 0,
            brute_angles = {60, -60, 30, -30, 90, -90, 0},
            hit_angles = {},
            miss_angles = {},
            last_velocity = {x = 0, y = 0, z = 0},
            moving = false,
            shots_fired = 0,
            shots_hit = 0,
            last_update = 0,
            last_resolve_angle = 0
        }
    end
end

local function cleanup_player_data()
    local current_time = globals_curtime()
    for player, data in pairs(resolver_data) do
        if not entity_is_alive(player) or (current_time - data.last_update) > 10 then
            resolver_data[player] = nil
        end
    end
end

-- ============================================
-- RESOLVER ALGORITHMS
-- ============================================

local function get_prediction_angle(player, data)
    local vx, vy = entity_get_prop(player, "m_vecVelocity")
    if not vx then return 0 end
    
    local speed = math_sqrt(vx * vx + vy * vy)
    data.moving = speed > 5
    
    if data.moving then
        local vel_angle = math_deg(math_atan2(vy, vx))
        return vel_angle + (data.misses % 2 == 0 and 90 or -90)
    else
        return data.misses % 2 == 0 and 60 or -60
    end
end

local function get_bruteforce_angle(player, data)
    return data.brute_angles[data.brute_phase + 1] or 0
end

local function get_adaptive_angle(player, data)
    if #data.hit_angles > 0 then
        return data.hit_angles[#data.hit_angles]
    end
    
    if #data.miss_angles > 2 then
        return -data.miss_angles[#data.miss_angles]
    end
    
    return data.misses % 2 == 0 and 60 or -60
end

local function get_hybrid_angle(player, data)
    local aggression = ui_get(menu.aggression) / 100
    
    if data.shots_fired > 3 then
        if data.shots_hit / data.shots_fired > 0.3 then
            return get_adaptive_angle(player, data)
        else
            return get_bruteforce_angle(player, data)
        end
    else
        return get_prediction_angle(player, data)
    end
end

local function resolve_player(player)
    if not ui_get(menu.resolver_enable) then return end
    
    init_player_data(player)
    local data = resolver_data[player]
    data.last_update = globals_curtime()
    
    local mode = ui_get(menu.resolver_mode)
    local resolver_angle = 0
    
    if mode == 0 then
        resolver_angle = get_adaptive_angle(player, data)
    elseif mode == 1 then
        resolver_angle = get_bruteforce_angle(player, data)
    elseif mode == 2 then
        resolver_angle = get_prediction_angle(player, data)
    elseif mode == 3 then
        resolver_angle = get_hybrid_angle(player, data)
    end
    
    if ui_get(menu.anti_freestand) then
        local freestand_active = ref.freestand[1] and ui_get(ref.freestand[1]) and ui_get(ref.freestand[2])
        if freestand_active then
            resolver_angle = resolver_angle * -1
        end
    end
    
    data.last_resolve_angle = resolver_angle
    plist_set(player, "Override resolver", 1)
    plist_set(player, "Override resolver value", resolver_angle)
end

-- ============================================
-- KILLSAY SYSTEM
-- ============================================

local messages = {
    toxic = {
        normal = {"ez", "sit", "?", "nn", "bot", "1", "L", "dog", "trash", "rekt"},
        headshot = {"hs only", "1 tap", "aim diff", "dink", "boom headshot"},
        knife = {"get knifed", "stabbed", "ty for skins", "$$$", "knife diff"},
        multi = {"double ez", "triple", "team diff", "squad wipe", "ace"},
        domination = {"owned again", "stop trying", "dominated", "you again?"}
    },
    troll = {
        normal = {"oops", "my bad", "lucky", ":)", "xd", "lol"},
        headshot = {"nice head", "calculated", "clean", "planned"},
        knife = {"backstab", "sneaky", "ninja", "surprise"},
        multi = {"multitasking", "speedrun", "efficiency"},
        domination = {"again?", "deja vu", "we meet again"}
    },
    meme = {
        normal = {"bruh", "oof", "F", "no u", "ratio", "L"},
        headshot = {"bonk", "dink", "POV:", "Pog", "KEKW"},
        knife = {"shank", "poke", "slice", "stab stab"},
        multi = {"stonks", "poggers", "gigachad"},
        domination = {"rent free", "obsessed", "simp"}
    },
    professional = {
        normal = {"gg", "wp", "nice try", "ns"},
        headshot = {"good shot", "nice aim", "excellent"},
        knife = {"nice knife", "good play"},
        multi = {"good round", "nice plays"},
        domination = {"gg again", "good match"}
    },
    custom_mix = {
        normal = {"gg ez", "outplayed", "skill issue", "diff"},
        headshot = {"crispy", "nasty", "filthy", "insane"},
        knife = {"violated", "disrespected"},
        multi = {"unstoppable", "godlike"},
        domination = {"permanent residence", "tenant"}
    }
}

local death_msgs = {
    excuses = {"lag", "my mouse died", "phone rang", "64 tick"},
    salty = {"hacker", "nice walls", "reported", "enjoy vac"},
    funny = {"worth", "calculated death", "tactical feed"},
    blame = {"team?", "no info", "baited", "bot teammates"},
    toxic = {"still won round", "scoreboard check", "k/d check"}
}

local kill_tracker = {
    per_player = {},
    kill_count = 0,
    streak = 0,
    best_streak = 0,
    last_kill_time = 0
}

local diagnostics = {
    start_time = globals_realtime(),
    resolver_hits = 0,
    resolver_misses = 0,
    killsay_sent = 0,
    deaths = 0
}

local function send_message(txt, dly)
    local mode = safe_get_combobox(ui_get(menu.killsay_mode))
    diagnostics.killsay_sent = diagnostics.killsay_sent + 1
    local cmd = mode == 0 and "say_team " or "say "
    if dly > 0 then
        client_delay_call(dly / 1000, function() client_exec(cmd .. txt) end)
    else
        client_exec(cmd .. txt)
    end
end

local function get_message_pool(style_name, category)
    if not messages[style_name] or not messages[style_name][category] then
        return messages.toxic[category]
    end
    return messages[style_name][category]
end

-- ============================================
-- CLANTAG SYSTEM
-- ============================================

local clantag_presets = {
    ["Custom"] = "",
    ["MISSWARE"] = "MISSWARE",
    ["P100"] = "P100",
    ["GODLIKE"] = "GODLIKE",
    ["EZ"] = "EZ",
    ["1TAP"] = "1TAP",
    ["RESOLVER"] = "RESOLVER",
    ["GAMING"] = "GAMING",
    ["PRO"] = "PRO",
    ["HVHGOD"] = "HVHGOD"
}

local separators = {
    ["None"] = {"", ""},
    ["[ ]"] = {"[", "]"},
    ["{ }"] = {"{", "}"},
    ["( )"] = {"(", ")"},
    ["| |"] = {"|", "|"},
    ["< >"] = {"<", ">"},
    ["» «"] = {"»", "«"},
    ["★ ★"] = {"★", "★"},
    ["• •"] = {"•", "•"},
    ["~ ~"] = {"~", "~"}
}

local ct_data = {
    last_update = 0,
    step = 0,
    direction = 1,
    glitch_timer = 0,
    last_text = ""
}
local ct_active = false

local function get_clantag_text()
    local preset_idx = safe_get_combobox(ui_get(menu.clantag_preset))
    local preset_names = {"Custom", "MISSWARE", "P100", "GODLIKE", "EZ", "1TAP", "RESOLVER", "GAMING", "PRO", "HVHGOD"}
    local preset_name = preset_names[preset_idx + 1] or "Custom"
    
    local text = ""
    if preset_name == "Custom" then
        text = ui_get(menu.clantag_custom_text) or "MISSWARE"
        if text == "" then text = "MISSWARE" end
    else
        text = clantag_presets[preset_name] or "MISSWARE"
    end
    return text
end

local function apply_separator(text)
    local sep_idx = safe_get_combobox(ui_get(menu.clantag_separator))
    local sep_names = {"None", "[ ]", "{ }", "( )", "| |", "< >", "» «", "★ ★", "• •", "~ ~"}
    local sep_name = sep_names[sep_idx + 1] or "None"
    local sep = separators[sep_name] or {"", ""}
    
    if sep[1] ~= "" then
        return sep[1] .. " " .. text .. " " .. sep[2]
    else
        return text
    end
end

local function apply_prefix_suffix(text)
    local prefix = ui_get(menu.clantag_prefix) or ""
    local suffix = ui_get(menu.clantag_suffix) or ""
    
    if prefix ~= "" then text = prefix .. " " .. text end
    if suffix ~= "" then text = text .. " " .. suffix end
    return text
end

local function truncate_text(text, max_len)
    if #text > max_len then
        return text:sub(1, max_len)
    end
    return text
end

local function animate_scroll(text)
    local max_len = ui_get(menu.clantag_max_length)
    local padding = string_rep(" ", math_floor(max_len / 2))
    local padded = padding .. text .. padding
    local pos = ct_data.step % #padded
    local result = padded:sub(pos + 1, pos + max_len)
    if #result < max_len then
        result = result .. padded:sub(1, max_len - #result)
    end
    return result
end

local function animate_fade(text)
    local steps = {}
    for i = 1, #text do table_insert(steps, text:sub(1, i)) end
    for i = 1, 3 do table_insert(steps, text) end
    for i = #text, 1, -1 do table_insert(steps, text:sub(1, i)) end
    for i = 1, 2 do table_insert(steps, "") end
    local idx = (ct_data.step % #steps) + 1
    return steps[idx]
end

local function animate_blink(text)
    return ct_data.step % 2 == 0 and text or ""
end

local function animate_wave(text)
    local result = {}
    for i = 1, #text do
        local offset = math_sin((ct_data.step + i) * 0.5)
        result[i] = offset > 0 and text:sub(i,i):upper() or text:sub(i,i):lower()
    end
    return table_concat(result)
end

local function animate_typewriter(text)
    local pause = 3
    local total_steps = #text + pause
    local pos = ct_data.step % total_steps
    if pos > #text then
        return text
    else
        return text:sub(1, pos)
    end
end

local function animate_reverse(text)
    if ct_data.direction == 1 then
        local len = math_min(ct_data.step, #text)
        local result = text:sub(1, len)
        if len >= #text then
            ct_data.direction = -1
            ct_data.step = #text
        end
        return result
    else
        local len = math_max(0, ct_data.step)
        local result = text:sub(1, len)
        if len <= 0 then
            ct_data.direction = 1
            ct_data.step = 0
        end
        return result
    end
end

local function animate_pingpong(text)
    local max_len = ui_get(menu.clantag_max_length)
    local padding = string_rep(" ", max_len)
    local full = padding .. text .. padding
    local max_pos = #full - max_len
    local cycle = max_pos * 2
    local raw_pos = ct_data.step % cycle
    local pos = 0
    if raw_pos <= max_pos then
        pos = raw_pos
    else
        pos = max_pos - (raw_pos - max_pos)
    end
    return full:sub(pos + 1, pos + max_len)
end

local function animate_rainbow(text)
    local rainbow_chars = {
        {"A", "a", "4", "@"},
        {"E", "e", "3"},
        {"I", "i", "1", "!"},
        {"O", "o", "0"},
        {"S", "s", "$", "5"},
        {"T", "t", "7"}
    }
    local result = text
    local variant = (ct_data.step % 4) + 1
    for i = 1, #rainbow_chars do
        local chars = rainbow_chars[i]
        if #chars >= variant then
            local from = chars[1]
            local to = chars[variant]
            result = result:gsub(from, to)
            result = result:gsub(from:lower(), to:lower())
        end
    end
    return result
end

local function animate_glitch(text)
    ct_data.glitch_timer = ct_data.glitch_timer + 1
    if ct_data.glitch_timer % 8 == 0 then
        local glitch_chars = {"█", "▓", "▒", "░", "▀", "▄"}
        local result = {}
        for i = 1, #text do
            if math_random(1, 4) == 1 then
                result[i] = glitch_chars[math_random(1, #glitch_chars)]
            else
                result[i] = text:sub(i, i)
            end
        end
        return table_concat(result)
    else
        return text
    end
end

local function animate_bounce(text)
    local result = {}
    for i = 1, #text do
        local offset = math_sin((ct_data.step * 0.3) + (i * 0.5)) * 2
        if math_floor(offset) > 0 then
            result[i] = text:sub(i, i):upper()
        else
            result[i] = text:sub(i, i):lower()
        end
    end
    return table_concat(result)
end

-- ============================================
-- EVENT HANDLERS
-- ============================================

-- Resolver events
client_set_event_callback("aim_fire", function(e)
    if not ui_get(menu.resolver_enable) then return end
    
    local player = e.target
    init_player_data(player)
    resolver_data[player].shots_fired = resolver_data[player].shots_fired + 1
end)

client_set_event_callback("aim_hit", function(e)
    if not ui_get(menu.resolver_enable) then return end
    
    local player = e.target
    init_player_data(player)
    local data = resolver_data[player]
    
    data.shots_hit = data.shots_hit + 1
    diagnostics.resolver_hits = diagnostics.resolver_hits + 1
    
    local current_override = plist_get(player, "Override resolver value")
    table_insert(data.hit_angles, current_override)
    
    if #data.hit_angles > 5 then
        table_remove(data.hit_angles, 1)
    end
    
    if ui_get(menu.resolver_debug) then
        client_color_log(150, 255, 150, string_format("[HIT] %s at %d°", 
            entity_get_player_name(player), current_override))
    end
end)

client_set_event_callback("aim_miss", function(e)
    if not ui_get(menu.resolver_enable) then return end
    
    local player = e.target
    init_player_data(player)
    local data = resolver_data[player]
    
    data.misses = data.misses + 1
    data.last_miss_tick = globals_tickcount()
    diagnostics.resolver_misses = diagnostics.resolver_misses + 1
    
    local current_override = plist_get(player, "Override resolver value")
    table_insert(data.miss_angles, current_override)
    
    if #data.miss_angles > 5 then
        table_remove(data.miss_angles, 1)
    end
    
    data.brute_phase = (data.brute_phase + 1) % #data.brute_angles
    
    if ui_get(menu.shot_correction) then
        resolve_player(player)
    end
    
    if ui_get(menu.resolver_debug) then
        client_color_log(255, 150, 150, string_format("[MISS] %s | Reason: %s | Phase: %d", 
            entity_get_player_name(player), e.reason, data.brute_phase))
    end
end)

-- Killsay events
client_set_event_callback("player_death", function(e)
    if not ui_get(menu.killsay_enable) then return end
    local me = entity_get_local_player()
    if not me then return end
    local atk = client_userid_to_entindex(e.attacker)
    local vic = client_userid_to_entindex(e.userid)
    
    if atk == me and vic ~= me then
        local dly = ui_get(menu.killsay_delay)
        local sty = safe_get_combobox(ui_get(menu.killsay_style))
        local style_names = {"toxic", "troll", "meme", "professional", "custom_mix"}
        local style_name = style_names[sty + 1] or "toxic"
        
        if not kill_tracker.per_player[vic] then kill_tracker.per_player[vic] = 0 end
        kill_tracker.per_player[vic] = kill_tracker.per_player[vic] + 1
        
        local ct = globals_curtime()
        if ct - kill_tracker.last_kill_time < 5 then
            kill_tracker.kill_count = kill_tracker.kill_count + 1
            kill_tracker.streak = kill_tracker.streak + 1
        else
            kill_tracker.kill_count = 1
            kill_tracker.streak = 1
        end
        kill_tracker.last_kill_time = ct
        if kill_tracker.streak > kill_tracker.best_streak then
            kill_tracker.best_streak = kill_tracker.streak
        end
        
        local msg = nil
        local wpn = e.weapon
        
        if ui_get(menu.on_multi) and kill_tracker.kill_count >= ui_get(menu.multi_threshold) then
            local pool = get_message_pool(style_name, "multi")
            msg = pool[math_random(1, #pool)]
        elseif ui_get(menu.domination) and kill_tracker.per_player[vic] >= ui_get(menu.domination_count) then
            local pool = get_message_pool(style_name, "domination")
            msg = pool[math_random(1, #pool)]
        elseif wpn and (wpn:find("knife") or wpn:find("bayonet")) and ui_get(menu.on_knife) then
            local pool = get_message_pool(style_name, "knife")
            msg = pool[math_random(1, #pool)]
        elseif e.headshot and ui_get(menu.on_headshot) then
            local pool = get_message_pool(style_name, "headshot")
            msg = pool[math_random(1, #pool)]
        elseif ui_get(menu.on_kill) then
            local pool = get_message_pool(style_name, "normal")
            msg = pool[math_random(1, #pool)]
        end
        
        if msg then send_message(msg, dly) end
        
    elseif vic == me and ui_get(menu.death_responses) then
        diagnostics.deaths = diagnostics.deaths + 1
        kill_tracker.streak = 0
        local dly = ui_get(menu.killsay_delay)
        local ds = safe_get_combobox(ui_get(menu.death_style))
        local death_style_names = {"excuses", "salty", "funny", "blame", "toxic"}
        local death_style = death_style_names[ds + 1] or "excuses"
        local pool = death_msgs[death_style]
        if pool and #pool > 0 then
            local msg = pool[math_random(1, #pool)]
            send_message(msg, dly + 500)
        end
    end
end)

-- Resolver main loop
client_set_event_callback("setup_command", function(cmd)
    if not ui_get(menu.resolver_enable) then return end
    
    local local_player = entity_get_local_player()
    if not local_player or not entity_is_alive(local_player) then return end
    
    local enemies = entity_get_players(true)
    
    for i = 1, #enemies do
        local player = enemies[i]
        if entity_is_alive(player) then
            resolve_player(player)
        end
    end
    
    if globals_tickcount() % 128 == 0 then
        cleanup_player_data()
    end
end)

-- Clantag animation
client_set_event_callback("run_command", function()
    local en = ui_get(menu.clantag_enable)
    if not en then
        if ct_active then
            client_set_clan_tag("")
            ct_active = false
        end
        return
    end
    ct_active = true
    local t = globals_realtime()
    local spd = ui_get(menu.clantag_speed)
    if t - ct_data.last_update < (0.3 / spd) then return end
    ct_data.last_update = t
    
    local text = get_clantag_text()
    local anim_idx = safe_get_combobox(ui_get(menu.clantag_animation))
    local animated = ""
    
    if anim_idx == 0 then
        animated = animate_scroll(text)
    elseif anim_idx == 1 then
        animated = animate_fade(text)
    elseif anim_idx == 2 then
        animated = animate_blink(text)
    elseif anim_idx == 3 then
        animated = animate_wave(text)
    elseif anim_idx == 4 then
        animated = animate_typewriter(text)
    elseif anim_idx == 5 then
        animated = animate_reverse(text)
        ct_data.step = ct_data.step + ct_data.direction
        client_set_clan_tag(apply_separator(apply_prefix_suffix(animated)))
        return
    elseif anim_idx == 6 then
        animated = animate_pingpong(text)
    elseif anim_idx == 7 then
        animated = animate_rainbow(text)
    elseif anim_idx == 8 then
        animated = animate_glitch(text)
    elseif anim_idx == 9 then
        animated = animate_bounce(text)
    else
        animated = text
    end
    
    animated = apply_separator(animated)
    animated = apply_prefix_suffix(animated)
    local max_len = ui_get(menu.clantag_max_length)
    animated = truncate_text(animated, max_len)
    client_set_clan_tag(animated)
    ct_data.last_text = animated
    ct_data.step = ct_data.step + 1
end)

-- Round start cleanup
client_set_event_callback("round_start", function()
    resolver_data = {}
    kill_tracker.per_player = {}
    kill_tracker.kill_count = 0
end)

-- ============================================
-- DIAGNOSTICS OVERLAY
-- ============================================

client_set_event_callback("paint", function()
    if ui_get(menu.show_diagnostics) then
        local y = 100
        local uptime = globals_realtime() - diagnostics.start_time
        
        renderer_text(10, y, 100, 255, 255, 255, "", 0, "═══ " .. script.name .. " " .. script.version .. " ═══") y = y + 20
        renderer_text(10, y, 150, 150, 150, 255, "", 0, string_format("Uptime: %ds", math_floor(uptime))) y = y + 15
        
        renderer_text(10, y, 100, 255, 100, 255, "", 0, "RESOLVER:") y = y + 15
        renderer_text(10, y, 255, 255, 255, 255, "", 0, "  Hits: " .. diagnostics.resolver_hits) y = y + 12
        renderer_text(10, y, 255, 255, 255, 255, "", 0, "  Misses: " .. diagnostics.resolver_misses) y = y + 12
        
        local hr = 0
        local total = diagnostics.resolver_hits + diagnostics.resolver_misses
        if total > 0 then hr = math_floor((diagnostics.resolver_hits / total) * 100) end
        local hr_r = hr > 50 and 100 or 255
        local hr_g = hr > 50 and 255 or 100
        renderer_text(10, y, hr_r, hr_g, 100, 255, "", 0, string_format("  Hit Rate: %d%%", hr)) y = y + 20
        
        renderer_text(10, y, 255, 200, 100, 255, "", 0, "KILLSAY:") y = y + 15
        renderer_text(10, y, 255, 255, 255, 255, "", 0, "  Sent: " .. diagnostics.killsay_sent) y = y + 12
        renderer_text(10, y, 255, 255, 255, 255, "", 0, "  Streak: " .. kill_tracker.streak .. " (Best: " .. kill_tracker.best_streak .. ")") y = y + 12
        renderer_text(10, y, 255, 255, 255, 255, "", 0, "  Deaths: " .. diagnostics.deaths)
    end
    
    if not ui_get(menu.resolver_debug) or not ui_get(menu.resolver_enable) then return end
    
    local me = entity_get_local_player()
    if not me or not entity_is_alive(me) then return end
    
    local y = 400
    renderer_text(10, y, 100, 255, 255, 255, "", 0, "═══ RESOLVER DEBUG ═══") y = y + 20
    
    local mode_names = {"ADAPTIVE", "BRUTEFORCE", "PREDICTION", "SMART HYBRID"}
    local mode_idx = ui_get(menu.resolver_mode) + 1
    if mode_idx < 1 or mode_idx > #mode_names then mode_idx = 1 end
    renderer_text(10, y, 100, 255, 255, 255, "", 0, "Mode: " .. mode_names[mode_idx]) y = y + 15
    
    local players = entity_get_players(true)
    if not players then return end
    
    for i = 1, #players do
        local p = players[i]
        if p and entity_is_alive(p) then
            local d = resolver_data[p]
            if d then
                local n = entity_get_player_name(p) or "?"
                local player_hr = 0
                local player_total = d.shots_hit + d.misses
                if player_total > 0 then player_hr = math_floor((d.shots_hit / player_total) * 100) end
                
                local r = player_hr > 50 and 100 or 255
                local g = player_hr > 50 and 255 or 100
                
                renderer_text(10, y, r, g, 100, 255, "", 0,
                    string_format("%s | %d° | %d%% | Phase:%d",
                    n, d.last_resolve_angle, player_hr, d.brute_phase))
                y = y + 12
            end
        end
    end
end)

-- ============================================
-- UI VISIBILITY MANAGEMENT
-- ============================================

local function update_visibility()
    local re = ui_get(menu.resolver_enable)
    local ke = ui_get(menu.killsay_enable)
    local ce = ui_get(menu.clantag_enable)
    local preset_idx = safe_get_combobox(ui_get(menu.clantag_preset))
    
    -- Resolver visibility
    ui_set_visible(menu.resolver_mode, re)
    ui_set_visible(menu.anti_freestand, re)
    ui_set_visible(menu.shot_correction, re)
    ui_set_visible(menu.aggression, re)
    ui_set_visible(menu.resolver_debug, re)
    
    -- Killsay visibility
    ui_set_visible(menu.killsay_mode, ke)
    ui_set_visible(menu.killsay_style, ke)
    ui_set_visible(menu.killsay_delay, ke)
    ui_set_visible(menu.on_kill, ke)
    ui_set_visible(menu.on_headshot, ke)
    ui_set_visible(menu.on_knife, ke)
    ui_set_visible(menu.on_multi, ke)
    ui_set_visible(menu.multi_threshold, ke and ui_get(menu.on_multi))
    ui_set_visible(menu.death_responses, ke)
    ui_set_visible(menu.death_style, ke and ui_get(menu.death_responses))
    ui_set_visible(menu.domination, ke)
    ui_set_visible(menu.domination_count, ke and ui_get(menu.domination))
    
    -- Clantag visibility
    ui_set_visible(menu.clantag_preset, ce)
    ui_set_visible(menu.clantag_custom_text, ce and preset_idx == 0)
    ui_set_visible(menu.clantag_animation, ce)
    ui_set_visible(menu.clantag_speed, ce)
    ui_set_visible(menu.clantag_separator, ce)
    ui_set_visible(menu.clantag_prefix, ce)
    ui_set_visible(menu.clantag_suffix, ce)
    ui_set_visible(menu.clantag_max_length, ce)
end

-- UI callbacks
ui_set_callback(menu.resolver_enable, update_visibility)
ui_set_callback(menu.killsay_enable, update_visibility)
ui_set_callback(menu.clantag_enable, update_visibility)
ui_set_callback(menu.clantag_preset, update_visibility)
ui_set_callback(menu.on_multi, update_visibility)
ui_set_callback(menu.death_responses, update_visibility)
ui_set_callback(menu.domination, update_visibility)

-- Initial visibility
update_visibility()

-- ============================================
-- CLEANUP ON SHUTDOWN
-- ============================================

client.set_event_callback("shutdown", function()
    client_set_clan_tag("")
end)

-- ============================================
-- INITIALIZATION COMPLETE
-- ============================================

client_color_log(150, 255, 150, string_format("%s v%s loaded successfully", script.name, script.version))
client_color_log(200, 200, 255, "Resolver: 4 modes | Killsay: 5 styles | Clantag: 10 animations")
